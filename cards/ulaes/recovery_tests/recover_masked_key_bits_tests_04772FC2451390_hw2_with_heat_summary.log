Summary of 
recover_masked_key_bits_tests_04772FC2451390_b48_0x00FF00FF_hw2_with_heat_20251020_182329.log
recover_masked_key_bits_tests_04772FC2451390_b48_0xFF00FF00_hw2_with_heat_20251020_180800.log
recover_masked_key_bits_tests_04772FC2451390_b49_0x00FF00FF_hw2_with_heat_20251020_184916.log
recover_masked_key_bits_tests_04772FC2451390_b49_0xFF00FF00_hw2_with_heat_20251020_183819.log
recover_masked_key_bits_tests_04772FC2451390_b50_0x00FF00FF_hw2_with_heat_20251020_191113.log
recover_masked_key_bits_tests_04772FC2451390_b50_0xFF00FF00_hw2_with_heat_20251020_190300.log
recover_masked_key_bits_tests_04772FC2451390_b51_0x00FF00FF_hw2_with_heat_20251020_192846.log
recover_masked_key_bits_tests_04772FC2451390_b51_0xFF00FF00_hw2_with_heat_20251020_192235.log

8 tests performed on segments with a key of HW=16
No overlap between tested bits, so the 8 bits cover each of the 128 bits of memory only once.

Quite some bitflips occur naturally even before heating, sometimes without action, sometimes by varying distance.
(typically the first results in the log files, before having time to start heating)

b48_0x00FF00FF:
 Recovered block bits:             ........................0.0.....
 Recovered block bits:             ........................0.00....
 Recovered block bits:             ..............0.........0.0.....
b48_0xFF00FF00:
 Recovered block bits:             .....0............0.............
 Recovered block bits:             1....0............0.............
 Recovered block bits:             1....0............0.0...........
 Recovered block bits:             1....0.0..........0.............
 Recovered block bits:             11...0............0.............
 Recovered block bits:             ..................0.............
b49_0x00FF00FF:
 Recovered block bits:             ...........1...1................
 Recovered block bits:             ...........11.11................
 Recovered block bits:             ...........1..11................
 Recovered block bits:             ...........1...1.........00.....
 Recovered block bits:             ...........1..11.........00.....
b49_0xFF00FF00:
 Recovered block bits:             ....................10..........
 Recovered block bits:             ....................1...........
 Recovered block bits:             .......0............1...........
 Recovered block bits:             ..0.................1...........
 Recovered block bits:             ...................010..........
b50_0x00FF00FF:
 Recovered block bits:             .........1......................
 Recovered block bits:             .........1..1...................
 Recovered block bits:             .........11.....................
 Recovered block bits:             .........1................1.....
 Recovered block bits:             .........1..1.1.................
 Recovered block bits:             .........1..1...............0...
 Recovered block bits:             .........1..1.............1.....
 Recovered block bits:             ................................
 Recovered block bits:             .........1................1.0...
b50_0xFF00FF00:
 Recovered block bits:             .....1.1........................
 Recovered block bits:             .....1.1...............1........
 Recovered block bits:             .....1.1........1...............
 Recovered block bits:             .....101........................
 Recovered block bits:             .0...101........................
 Recovered block bits:             .....101........1...............
 Recovered block bits:             .......1........................
 Recovered block bits:             .......1........1...............
 Recovered block bits:             10...101........1...............
 Recovered block bits:             1....101........1...............
b51_0x00FF00FF:
 Recovered block bits:             .............0..........0.......
 Recovered block bits:             ........1....0..........0.......
 Recovered block bits:             .............0.1........0.......
 Recovered block bits:             .............0..........0......1
 Recovered block bits:             .............0..........0...1..1
 Recovered block bits:             .............0..........0...1.01
 Recovered block bits:             .............0..................
b51_0xFF00FF00:
 Recovered block bits:             .....................11.........
 Recovered block bits:             .0...................11.........
 Recovered block bits:             ................0...111.........
 Recovered block bits:             .....0...............11.........
 Recovered block bits:             ....................1110........
 Recovered block bits:             ....................111.........
 Recovered block bits:             .....0.1.............11.........



b48_0x00FF00FF_hw2: recovered 4 bits
b48_0xFF00FF00_hw2: recovered 6 bits
b49_0x00FF00FF_hw2: recovered 6 bits
b49_0xFF00FF00_hw2: recovered 5 bits
b50_0x00FF00FF_hw2: recovered 6 bits
b50_0xFF00FF00_hw2: recovered 7 bits
b51_0x00FF00FF_hw2: recovered 7 bits
b51_0xFF00FF00_hw2: recovered 7 bits
(4+6+6+5+6+7+7+7)/8 = 6 bits recovered per segment on average

We decided to test the revival techniques described in Section~\ref{sec:envweak} on the Ultralight~AES.
The strategy is to limit brute-force attempts to candidates at a Hamming Distance $\leq 2$ so the attempts remain quick.
We first apply a series of tearing operations on one segment until we manage to recover about 2 bits of that segment.
Then, the script continues to attempt to authenticate with the partially recovered key and every time it fails, it initiates a quick brute-force, with a HD to the known partial key $\leq 2$ to find more bits, and if it succeeds, it adds the partial key to its list.
While it's constantly running, we apply environmental changes such as changing the card position and heating the card to increase the likelihood of bitflips.
Actually, even before we start heating, we often observe some bitflips just by repeatedly authenticating.
We performed 8 tests on segments with every time a key segment of HW=16 and we made sure each test covered 16 different bits of the 128-bit key slot, without any overlap.
On average, we managed to recover 6 bits per segment, which means that with 20 cards, we can recover the full 128-bit key in about 2 hours.
Heating to 100-110$\,^{\circ}$C...

In theory, how to revert even more bits?
- writing and interrupting FFFFFFFF without erasing first
- find a way to bias the read voltage even more than with heat
- find a way to bias the read voltage in the opposite direction when tearing up to HW=2
If N bits not yet recovered, use reader nonce brute-force with HD <= N to find more bits

If 4*6=24 bits recovered, over a key of HW=64, there remains 40 bits to find.
Offline BF of reader nonce with HD=40:

At 10000000000 keys/s (offline bruteforce of reader nonce)
ULAES  estimate(128,  40): 2^111.80 in 5244042226984961024.00 days

=> tear and look for HW<=4
=> 511s per attempt. If 30 tears => 4.25 hours per segment.
Then revive 4 more bits
=> 8 bits per segment => *4 = 32 bits recovered, 32 bits to go => still 2^100 offline attempts on reader nonce.

=> tear and look for HW<=6
=> 4h per attempt. If 30 tears => 120 hours per segment.
Then revive 4 more bits
=> 10 bits per segment => *4 = 40 bits recovered, 24 bits to go

=> tear and look for HW<=6
=> 4h per attempt. If 30 tears => 120 hours per segment.
Then revive 7 more bits
=> 13 bits per segment => *4 = 52 bits recovered, 12 bits to go
ULAES  estimate(128,  12): 2^54.55 in    30.56 days (    7.34 hours on 100 GPU)

this is assuming that by starting from a less erased key (hw=6), more bits can be revived (I could revive 4 bits on avg, let's assume I could revive 7 bits).
This could be simulated on RFU pages, to see the behavior...
a difficulty is that the bf of HW<=6 is still "random": key is unstable during the search. This is also true for HW<=2 but more critical when a single pass takes 120h...

I tried on RFU blocks starting with tears up to HW=6, but I can juste revive painfully a couple of extra bits at best, so 8 bits in total :(
