#!/usr/bin/env python3
"""Print LaTeX table for summarizing attacks."""

import math
import mpmath as mp

ULC_PARAMS = {
    "target": r"Ultralight~C",
    "bits": 112,
    "nsegments": 4,
    # ULC auth brute-force: theoretical max is about 137 keys/s)
    "kps_theo": 137,
    # experimentally measured: 100 keys/s
    "kps": 100,
    # experimentally measured: 86 keys/s when including tearings and multiple segmented auths
    "kps_tear": 86,
    # experimentally measured: larger auths than theory when tearing because of weak bits
    "auths_tear_factor": 1.9,
    # approximate number of tears to reach HW=1.52, measured experimentally
    # FIXME: approximate number of tears to reach HW=2 or HW=3
    "segment_ntears_hw": {1.52: 7.19, 2: 20, 3: 20},
    # because of weak bits, we may need to retry the same key candidates multiple times
    "tear_bf_retries": 0,
    # RTX4090 offline bruteforce speed in keys/s with 70 GPU
    "kps_off": 9 / 4 * 70 * 21.19 * 10**9 / 2,
    # RTX4090 offline bruteforce cost of 70 GPU, in $/s
    "cost_off": 0.29 / 3600 * 70,
    # FIXME: reader auths per second when relaying (including the time to write one segment before each auth)
    "kps_reader": 2,
}

ULAES_PARAMS = {
    "target": r"Ultralight~AES (per key)",
    "bits": 128,
    "nsegments": 4,
    # ULAES brute-force: theoretical max is about 100 keys/s
    "kps_theo": 100,
    # pm3 PoC "hf mfu aeschk" brute-force from client file:   73.0 keys/s
    # providing a full refkey and a dict for a segment:       82.9 keys/s
    # without client file bottleneck (keys generated by pm3): 87.3 keys/s
    # new measure hf mfu aeschk -f client/dictionaries/mfulaes_segment_hw2.dic -s 0 -k 11111111111111111111111111111111
    "kps": 88,
    # experimentally measured: keys/s when including tearings and multiple segmented auths
    "kps_tear": 81,
    # experimentally measured: TODO: larger auths than theory when tearing because of weak bits
    "auths_tear_factor": 1,
    # approximate number of tears to reach HW=2 or HW=3, measured experimentally
    # quite large number because we need to start from a safe margin no matter which block is targeted
    # and we don't know the exact parameter of each block holding a key segment
    "segment_ntears_hw": {2: 30, 3: 30},
    # because of weak bits, we may need to retry the same key candidates multiple times
    # experiment: doable without retry
    "tear_bf_retries": 0,
    # approximate number of tears to recover a mask segment. Experimental measure
    # 176 + 40 confirmation tears without brute-force
    "ntears_mask": 216,
    # approximate number of auths to recover a mask segment. Experimental measure, including retries
    "tear_mask_bf": 4316,
    # RTX4090 offline bruteforce speed
    "kps_off": 1.14 * 2**40,
    # RTX4090 offline bruteforce cost, in $/s
    "cost_off": 0.00764
}


NTAG224_PARAMS = {
    "target": r"NTAG224 AES\_KEY",
    # Same params as ULAES except for mask recovery
    "bits": 128,
    "nsegments": 4,
    "kps_theo": 100,
    "kps": 83,
    "kps_tear": 83,
    "auths_tear_factor": 1,
    "segment_ntears_hw": {2: 30, 3: 30},
    "tear_bf_retries": 0,
    "kps_off": 1.14 * 2**40,
    "cost_off": 0.00764
}


NTAG22x_SUNMAC_PARAMS = {
    "target": r"NTAG22x SUNCMAC\_KEY",
    "bits": 128,
    "nsegments": 4,
    # Python PoC on i9 with 20 cores: 38 min on average for 2**31
    "kps_off": 2**32 / 2 / (38 * 60),
    # SUNCMAC + mask with tearing: experimental measurements on 5 samples, average:
    # collecting   80 MACs with 182 tears            in 35   seconds
    # (per segment: including 10 confirmation tears)
    # bruteforcing 80 MACs with 1 700 000 candidates in  2.7 seconds
    "ntears": 182,
    "tearsps": 182 / 35,
    "nmac_coll": 80,
    "tear_bf": 1700000,
    "kps_tear": 1700000 / 2.7,
}


def time_string(seconds):
    """Convert seconds to a human-readable time string."""
    if seconds < 60:
        return fr"{seconds:.1f}~s"
    elif seconds < 3600:
        return fr"{seconds / 60:.1f}~min"
    elif seconds < 86400:
        return fr"{seconds / 3600:.1f}~h"
    else:
        return fr"{seconds / 86400:.1f}~d"


def binom_real(n, m):
    """Calculate the binomial coefficient C(n, m) for real m using gamma function."""
    # To be use instead of math.comb to work on floats
    # C(x, y) = Γ(x + 1) / (Γ(y + 1) Γ(x − y + 1))
    return float(mp.gamma(n+1)/(mp.gamma(m+1)*mp.gamma(n-m+1)))


def estimate_low_hw_candidates(n, m):
    """Estimate the number of candidates with HW <= m for a n-bit key.

    Args:
        n (int): Number of bits in the key.
        m (int): Maximum number of bits in the hardware candidates.
    Returns:
        float: Estimated number of candidates.
    """
    num = math.comb(n, 0)
    for i in range(1, m + 1):
        num += math.comb(n, i)
    return num


def expected_unique_bits(n=14, bits_per_draw=3.0, num_draws=6):
    """Estimate the expected number of unique bits revealed by tearing.

    When drawing `bits_per_draw` bits from a total of `n` bits, over `num_draws` draws.

    Args:
        n (int): Total number of unique bits.
        bits_per_draw (int): Number of bits drawn in each draw.
        num_draws (int): Total number of draws.
    Returns:
        float: Expected number of unique bits revealed.
    """
    # Probability a specific bit is not drawn in one draw
    p_not_in_one_draw = binom_real(n-1, bits_per_draw) / binom_real(n, bits_per_draw)
    # Probability not drawn in any of the num_draws
    p_never_drawn = p_not_in_one_draw ** num_draws
    # So expected number of bits seen at least once:
    expected = n * (1 - p_never_drawn)
    return expected


def print_table_header():
    """Print the header of the LaTeX table."""
    print(r"""
{
\renewcommand{\arraystretch}{1.4}
\renewcommand\tabularxcolumn[1]{>{\raggedright\arraybackslash}m{#1}}
\begin{table}[h]
\caption{Comparison of presented attacks with their requirements and execution times}
\label{tab:summarized-attacks}
\centering
\begin{adjustbox}{center,max width=0.95\textwidth,max totalheight=0.75\textheight}
\begin{tabularx}{\linewidth}{|l|X|X|X|X|X|X|X|}
\hline
  \textbf{\scriptsize Target} &
  \textbf{\scriptsize Cards} &
  \textbf{\scriptsize Devices} &
  \textbf{\scriptsize Reader auth attempts (average)} &
  \textbf{\scriptsize Card auth attempts (average)} &
  \textbf{\scriptsize Offline operations (average)} &
  \textbf{\scriptsize Tearing events (average)} &
  \textbf{\scriptsize Time (average)} \\ \hline
\noalign{\hrule height 0.6pt}
""")


def print_table_footer():
    """Print the footer of the LaTeX table."""
    print(r"""
\end{tabularx}
\end{adjustbox}
\end{table}
}
* if AUTH0 needs to be changed to a higher value on N of the cards.
Note that the additional device required for the relay may also be used to accelerate the brute-force phases.

$\dagger$ if pages 44-47 are locked or if AUTH0 is locked.

$\ddagger$ it assumes the mask has already been recovered, which is included in the \emph{SUNCMAC\_KEY with tearing} operations.
""")


def print_table_row(target, cards, devices, raa, caa, obf, tears, time):
    """Print a row in the LaTeX table."""
    if r"\\" in target:
        target = fr"\makecell[l]{{{target}}}"
    print(fr"  {target} & {cards} & {devices} & {raa} & {caa} & {obf} & {tears} & {time} \\ \hline")


def print_table_hline():
    """Print a horizontal line in the LaTeX table."""
    print(r"\noalign{\hrule height 0.6pt}")


def print_table_row_detectkdf():
    """Print Detect KDF scenario."""
    # cf \section{Assessing Key Diversification in Deployed Systems}
    target = r"Detect KDF, all"
    ncards = 1
    cards = fr"{ncards}"
    devices = r"2"
    raa = r"2"
    caa = r"2"
    obf = r"--"
    tears = r"--"
    time = r"instant"
    print_table_row(target, cards, devices, raa, caa, obf, tears, time)


def compute_nxp_and_print_row(params, single_device=False, offline_segments=0, tearing=False, hw=0.0, heat_hw=None, silent=False, target=None, reader_bf_segments=0):
    """Compute the parameters for a row in the LaTeX table."""
    assert offline_segments in [0, 1, 2]
    assert reader_bf_segments in [0, 1]
    if tearing:
        assert hw > 0
    segment_bits = params["bits"] // params["nsegments"]
    segment_keyspace = 2**segment_bits

    # Cards:
    remaining_bits = 0
    if not tearing:
        ncards = params["nsegments"] - offline_segments - reader_bf_segments
        cards = fr"{ncards}"
    else:
        # - if each card reveals "hw" bits out of "segment_keyspace" on average (can be less if too much teared,
        # can be more if we can revive a couple of bits once the first bruteforce succeeded)
        # - if key segments have an average HW=segment_keyspace/2 (as many ones as zeroes)
        ncards_tear_segment = 1
        # with that many cards, how many bits left to find?
        while True:
            remaining_bits = segment_bits//2 - expected_unique_bits(segment_bits//2, heat_hw if heat_hw is not None else hw, ncards_tear_segment)
            # no more than N bits to brute-force
            if remaining_bits < 3.5:
                break
            ncards_tear_segment += 1
        ncards_tear = (params["nsegments"] - offline_segments) * ncards_tear_segment
        ncards_last = params["nsegments"] - offline_segments
        ncards = ncards_tear + ncards_last
        cards = fr"$\mathord{{\approx}}{ncards}$"

    # Devices:
    if single_device or ncards > params["nsegments"]:
        # 1, else for the auth via relay,
        # (in which case the second can be used for the brute-force as well to attack a second card.)
        ndevices = 1
        devices = r"1~(2)$^*$"
    else:
        # to // all brute-force
        ndevices = ncards
        # if reader BF, we need an additional device to automate the alternating phases of
        # writing the card and presenting the card to the reader (via a relay)
        if reader_bf_segments > 0:
            ndevices += 1
        devices = fr"{ndevices}"

    # Reader auth attempts:
    if offline_segments == 0:
        # only for relaying one auth *per card* to change AUTH0
        nraa = 0
        raa = r"--~(N)$^*$"
    else:
        if reader_bf_segments == 0:
            # 1: to get one nonce for the offline brute-force
            # N: only for relaying one auth *per card* to change AUTH0
            nraa = 1
            raa = r"1~(N)$^*$"
        else:
            # 1: to get one nonce for the offline brute-force
            nraa = segment_keyspace / 2 * ncards
            raa = fr"$2^{{{math.log2(nraa):.1f}}}$"

    # Card auth attempts (average):
    if not tearing:
        # segment takes half of keyspace on average, times number of cards
        ncaa = segment_keyspace / 2 * ncards
    else:
        estimation = estimate_low_hw_candidates(segment_bits, math.ceil(hw))
        # For teared cards, we consider the whole keyspace and not its half, except for last tear,
        # because, until we reached the desired HW, we've to cover the entire keyspace.
        ncaa = (estimation
                * params["auths_tear_factor"]
                * (2 if heat_hw is not None else 1)
                * (params["segment_ntears_hw"][hw] - 0.5)
                * (1 + params["tear_bf_retries"])
                * ncards_tear)
        ncaa += estimate_low_hw_candidates(segment_bits, math.ceil(remaining_bits)) / 2 * ncards_last
        if "tear_mask_bf" in params:
            ncaa += params["tear_mask_bf"] * ncards_tear
    caa = fr"$2^{{{math.log2(ncaa):.1f}}}$"

    # Offline brute-force (average):
    if offline_segments == 0:
        nobf = 0
        obf = r"--"
    else:
        if not tearing:
            nobf = (segment_keyspace ** (params["nsegments"] - ncards - reader_bf_segments))/2
        else:
            nobf = (segment_keyspace ** (params["nsegments"] - ncards_last))/2
        obf = fr"$2^{{{math.log2(nobf):.1f}}}$"

    # Tearing:
    if not tearing:
        ntears = 0
        tears = r"--"
    else:
        ntears = ncards_tear * params["segment_ntears_hw"][hw]
        if "ntears_mask" in params:
            ntears += params["ntears_mask"] * ncards_tear
        tears = fr"$2^{{{math.log2(ntears):.1f}}}$"

    # Time (average):
    if tearing:
        avg_time = ncaa / params["kps_tear"]
    elif single_device:
        # If 2 devices available, considering 2 cards per reader, we can just do 2*24.8 = 49.6 as upper bound
        # (corresponding to cracking 2 cards in // then 2 more cards in //).
        # It's actually a bit more complex as the first reader to finish the first card can start immediately on a new card
        # To keep it simple, we just mention the possible optimization in the * footnote.
        avg_time = ncaa / params["kps"]
    else:
        max_seconds_per_card = segment_keyspace / params["kps"]
        # If N devices available, it takes on average the average of the longest one of the N to crack.
        # Formula: cf refs/cdf.md
        if ncards == 1:
            avg_time = max_seconds_per_card / 2
        else:
            avg_time = max_seconds_per_card * ndevices / (ndevices + 1)
    if reader_bf_segments > 0:
        # time for writing segment and relaying auth with the reader
        avg_time += nraa / params["kps_reader"]
    time = time_string(avg_time)
    avg_time_off = 0
    if nobf >= 2**50:
        avg_time_off = nobf / params["kps_off"]
        avg_cost = avg_time_off * params["cost_off"]
        time = fr"{time_string(avg_time+avg_time_off)} + \${round(avg_cost)}"
    if not silent:
        print_table_row(params["target"] if target is None else target, cards, devices, raa, caa, obf, tears, time)
    return ncards, cards, ndevices, devices, nraa, raa, ncaa, caa, nobf, obf, ntears, tears, avg_time, avg_time_off, time


def print_table_row_ulc_4c_1d():
    """Print ULC (1 online PKO per card, 1 or 2 devices)."""
    # cf \section{Keyspace Reduction via 75\% Key Overwrite Relay}
    compute_nxp_and_print_row(ULC_PARAMS, single_device=True)


def print_table_row_ulc_4c_4d():
    """Print ULC (1 online PKO per card, 4 devices)."""
    # cf \section{Keyspace Reduction via 75\% Key Overwrite Relay}
    compute_nxp_and_print_row(ULC_PARAMS)


def print_table_row_ulc_3c_3d():
    """Print ULC (1 online PKO per card, last segment offline, 3 devices)."""
    # cf \section{Improved Attack by Collecting Reader Nonces}
    compute_nxp_and_print_row(ULC_PARAMS, offline_segments=1)


def print_table_row_ulc_2c_2d():
    """Print ULC (1 online PKO per card, last 2 segments offline, 2 devices)."""
    # cf \section{Improved Attack by Collecting Reader Nonces}
    # We assume 2 devices to simplify the line
    compute_nxp_and_print_row(ULC_PARAMS, offline_segments=2)


def print_table_row_ulc_1c_1d():
    """Print ULC (1 online segment with reader, 1 online segment, 2 segments offline)."""
    # cf \section{Ultralight~C: Theoretical Single-Card Key Recovery Method}
    compute_nxp_and_print_row(ULC_PARAMS, offline_segments=2, reader_bf_segments=1)


def print_table_row_ulc_tear_hw3():
    """Print ULC (with tearing to HW=3)."""
    # cf \section{Further Keyspace Reduction via Tearing}
    compute_nxp_and_print_row(ULC_PARAMS, tearing=True, hw=3)


def print_table_row_ulc_tear_hw155():
    """Print ULC (with tearing to HW=1.52)."""
    # cf \section{Further Keyspace Reduction via Tearing}
    compute_nxp_and_print_row(ULC_PARAMS, tearing=True, hw=1.52)


def print_table_row_ulc_3c_3d_tear_hw3():
    """Print ULC (1 online PKO per card, last segment offline, 3 devices, with tearing to HW=3)."""
    # cf \section{Further Keyspace Reduction via Tearing}
    # cf \section{Improved Attack by Collecting Reader Nonces}
    compute_nxp_and_print_row(ULC_PARAMS, offline_segments=1, tearing=True, hw=3)


def print_table_row_gt23sc4489():
    """Print ULCG."""
    target = r"GT23SC4489\\even if locked"
    segment_bits = ULC_PARAMS["bits"] // ULC_PARAMS["nsegments"]
    segment_keyspace = 2**segment_bits
    # Cards:
    ncards = 1
    cards = fr"{ncards}"
    # Devices:
    ndevices = ncards
    devices = fr"{ndevices}"
    # Reader auth attempts: 1 if AUTH0, but without relay, with a recurring nonce
    raa = r"--~(1)$^*$"
    # - Card auth attempts (average)
    # 4 for PKO, ~49 if looking for recurring nonce = wait to see 3x same nonce
    # ulcg/data/analysis_duplicates.py
    # Number of events with at least one duplicate found over 10000 events: 10000 = 100.00% of events with n=49 nonces.
    # Average max count of duplicates: 3.01
    caa_pko = ULC_PARAMS["nsegments"]
    caa_nonce_3x = 49
    caa = fr"{caa_pko}~($2^{{{math.log2(caa_nonce_3x):.1f}}}$)"
    # Offline brute-force (average): each card: segment takes $2^{27}$ on average, $\times 4~segments = 2^{29}$
    nobf = segment_keyspace / 2 * ULC_PARAMS["nsegments"]
    obf = fr"$2^{{{math.log2(nobf):.1f}}}$"
    # Tearing: if needed to unlock lock bits, 1 shot easy
    tears = r"--~(1)$^\dagger$"
    # Time (average)
    # - Tested on PC: 1 minute
    # - + 1 if need to collect nonces
    time = r"1~(2)$^*$~min"
    print_table_row(target, cards, devices, raa, caa, obf, tears, time)


def print_table_row_fj8010():
    """Print FJ8010."""
    target = r"FJ8010"
    segment_bits = ULC_PARAMS["bits"] // ULC_PARAMS["nsegments"]
    segment_keyspace = 2**segment_bits
    # Cards:
    ncards = 1
    cards = fr"{ncards}"
    # Devices:
    ndevices = ncards
    devices = fr"{ndevices}"
    # Reader auth attempts: 1 if AUTH0, but without relay, with a recurring nonce
    raa = r"--~(1)$^*$"
    # - Card auth attempts (average)
    # 4 for PKO, ~49 if looking for recurring nonce = wait to see 3x same nonce
    # analysis_duplicates.py
    # Number of events with at least one duplicate found over 10000 events: 10000 = 100.00% of events with n=49 nonces.
    # Average max count of duplicates: 3.03
    caa_pko = ULC_PARAMS["nsegments"]
    caa_nonce_3x = 49
    caa = fr"{caa_pko}~($2^{{{math.log2(caa_nonce_3x):.1f}}}$)"
    # Offline brute-force (average): each card: segment takes $2^{27}$ on average, $\times 4~segments = 2^{29}$
    nobf = segment_keyspace / 2 * ULC_PARAMS["nsegments"]
    obf = fr"$2^{{{math.log2(nobf):.1f}}}$"
    # Tearing: none
    tears = r"--"
    # Time (average)
    # - Tested on PC: 1 minute
    # - + 1 if need to collect nonces
    time = r"1~(2)$^*$~min"
    print_table_row(target, cards, devices, raa, caa, obf, tears, time)


def print_table_row_uscuid_ul():
    """Print USCUID-UL."""
    target = r"USCUID-UL"
    segment_bits = ULC_PARAMS["bits"] // ULC_PARAMS["nsegments"]
    segment_keyspace = 2**segment_bits
    # Cards:
    ncards = 1
    cards = fr"{ncards}"
    # Devices:
    ndevices = ncards
    devices = fr"{ndevices}"
    # Reader auth attempts: 1 if AUTH0, but without relay, with a recurring nonce
    raa = r"--~(1)$^*$"
    # - Card auth attempts (average)
    # 4 for PKO, ~153 if looking for recurring nonce = wait to see 3x same nonce
    # uscuid-ul/data/analysis_duplicates.py
    # Number of events with at least one duplicate found over 10000 events: 10000 = 100.00% of events with n=153 nonces.
    # Average max count of duplicates: 2.99
    caa_pko = ULC_PARAMS["nsegments"]
    caa_nonce_3x = 153
    caa = fr"{caa_pko}~($2^{{{math.log2(caa_nonce_3x):.1f}}}$)"
    # Offline brute-force (average): each card: segment takes $2^{27}$ on average, $\times 4~segments = 2^{29}$
    nobf = segment_keyspace / 2 * ULC_PARAMS["nsegments"]
    obf = fr"$2^{{{math.log2(nobf):.1f}}}$"
    # Tearing: none
    tears = r"--"
    # Time (average)
    # - Tested on PC: 1 minute
    # - + 1 if need to collect nonces
    time = r"1~(2)$^*$~min"
    print_table_row(target, cards, devices, raa, caa, obf, tears, time)


def print_table_row_ulaes_4c_1d():
    """Print Ultralight~AES (1 online PKO per card, 1 or 2 devices)."""
    # cf \subsection{Ultralight~AES: \\Keyspace Reduction}
    compute_nxp_and_print_row(ULAES_PARAMS, single_device=True)


def print_table_row_ulaes_4c_4d():
    """Print ULAES (1 online PKO per card, 4 devices)."""
    # cf \subsection{Ultralight~AES: \\Keyspace Reduction}
    compute_nxp_and_print_row(ULAES_PARAMS)


def print_table_row_ulaes_3c_3d():
    """Print ULAES (1 online PKO per card, last segment offline, 3 devices)."""
    # cf \subsection{Ultralight~AES: Reader Nonces, Online Attack Enhancements}
    compute_nxp_and_print_row(ULAES_PARAMS, offline_segments=1)


def print_table_row_ulaes_tear_hw3():
    """Print ULAES (with tearing to HW=3)."""
    # cf \subsection{Ultralight~AES: Tearing}
    compute_nxp_and_print_row(ULAES_PARAMS, tearing=True, hw=3)


def print_table_row_ulaes_tear_hw2():
    """Print ULAES (with tearing to HW=2)."""
    # cf \subsection{Ultralight~AES: Tearing}
    compute_nxp_and_print_row(ULAES_PARAMS, tearing=True, hw=2)


def print_table_row_ulaes_tear_hw2_heat():
    """Print ULAES (with tearing to HW=6)."""
    # cf \subsection{Ultralight~AES: Tearing}
    compute_nxp_and_print_row(ULAES_PARAMS, tearing=True, hw=2, heat_hw=6, target=ULAES_PARAMS["target"]+"+heat")


def print_table_row_ulaes_3c_3d_tear_hw3():
    """Print ULAES (1 online PKO per card, last segment offline, 3 devices, with tearing to HW=3)."""
    # cf \subsection{Ultralight~AES: Tearing}
    # cf \subsection{Ultralight~AES: Reader Nonces, Online Attack Enhancements}
    compute_nxp_and_print_row(ULAES_PARAMS, offline_segments=1, tearing=True, hw=3)


def print_table_row_ulaes_reader():
    """Print UL~AES reader with broken TRNG."""
    # cf \subsection{Ultralight~AES: Protocol Oddity}
    target = r"UL~AES reader\\with broken TRNG"
    cards = r"--"
    devices = r"1"
    raa = r"1"
    caa = r"--"
    obf = r"--"
    tears = r"--"
    time = r"instant"
    print_table_row(target, cards, devices, raa, caa, obf, tears, time)


def print_table_row_ntag224_aes_4c_1d():
    """Print NTAG224 AES_KEY (1 online PKO per card, 1 or 2 devices)."""
    # cf \subsection{NTAG~224~DNA: \texttt{AES\_KEY} Keyspace Reduction}
    # Same as for ULAES
    compute_nxp_and_print_row(NTAG224_PARAMS, single_device=True)


def print_table_row_ntag224_aes_4c_4d():
    """Print NTAG224 AES_KEY (1 online PKO per card, 4 devices)."""
    # cf \subsection{NTAG~224~DNA: \texttt{AES\_KEY} Keyspace Reduction}
    # Same as for ULAES
    compute_nxp_and_print_row(NTAG224_PARAMS)


def print_table_row_ntag224_aes_3c_3d():
    """Print NTAG224 AES_KEY (1 online PKO per card, last segment offline, 3 devices)."""
    # cf \subsection{NTAG~224~DNA: Reader Nonces, Online Attack Enhancements}
    # Same as for ULAES
    compute_nxp_and_print_row(NTAG224_PARAMS, offline_segments=1)


def print_table_row_ntag224_aes_tear_hw2():
    """Print NTAG224 AES_KEY (with tearing to HW=2)."""
    # cf \subsection{NTAG~224~DNA: Tearing}
    target = NTAG224_PARAMS["target"]
    compute_nxp_and_print_row(NTAG224_PARAMS, tearing=True, hw=2, target=target+"$^\\ddagger$")


def print_table_row_ntag22x_suncmac():
    """Print NTAG22x SUNCMAC."""
    target = NTAG22x_SUNMAC_PARAMS["target"]
    ncards = 1
    cards = fr"{ncards}"
    devices = r"1~(2)$^*$"
    raa = r"--~(1)$^*$"
    caa = fr"{NTAG22x_SUNMAC_PARAMS["nsegments"]}~MAC"
    segment_bits = NTAG22x_SUNMAC_PARAMS["bits"] // NTAG22x_SUNMAC_PARAMS["nsegments"]
    segment_keyspace = 2**segment_bits
    nobf = segment_keyspace / 2 * NTAG22x_SUNMAC_PARAMS["nsegments"]
    obf = fr"$2^{{{math.log2(nobf):.1f}}}$"
    tears = r"--"
    avg_time_off = nobf / NTAG22x_SUNMAC_PARAMS["kps_off"]
    time = fr"{time_string(avg_time_off)}"
    print_table_row(target, cards, devices, raa, caa, obf, tears, time)


def print_table_row_ntag22x_suncmac_tear():
    """Print NTAG22x SUNCMAC."""
    target = NTAG22x_SUNMAC_PARAMS["target"]
    cards = r"1"
    devices = r"1~(2)$^*$"
    raa = r"--~(1)$^*$"
    ntears = NTAG22x_SUNMAC_PARAMS["ntears"]
    caa = fr"$2^{{{math.log2(ntears):.1f}}}$~MAC"
    nobf = NTAG22x_SUNMAC_PARAMS["tear_bf"]
    obf = fr"$2^{{{math.log2(nobf):.1f}}}$"
    tears = fr"$2^{{{math.log2(ntears):.1f}}}$"
    avg_time = ntears / NTAG22x_SUNMAC_PARAMS["tearsps"]
    avg_time += nobf / NTAG22x_SUNMAC_PARAMS["kps_tear"]
    time = fr"{time_string(avg_time)}"
    print_table_row(target, cards, devices, raa, caa, obf, tears, time)


def print_table_row_ntag224_reader():
    """Print NTAG224 reader with broken TRNG."""
    # cf \subsection{NTAG~224~DNA: Protocol Oddity}
    target = r"NTAG224 reader\\with broken TRNG"
    cards = r"--"
    devices = r"1"
    raa = r"1"
    caa = r"--"
    obf = r"--"
    tears = r"--"
    time = r"instant"
    print_table_row(target, cards, devices, raa, caa, obf, tears, time)


def main():
    """Print the summary table."""
    print_table_header()
    print_table_row_detectkdf()
    print_table_hline()
    print_table_row_ulc_4c_1d()
    print_table_row_ulc_4c_4d()
    print_table_row_ulc_3c_3d()
    print_table_row_ulc_2c_2d()
    print_table_row_ulc_1c_1d()
    print_table_row_ulc_3c_3d_tear_hw3()
    print_table_row_ulc_tear_hw3()
    print_table_row_ulc_tear_hw155()
    print_table_hline()
    print_table_row_gt23sc4489()
    print_table_row_fj8010()
    print_table_row_uscuid_ul()
    print_table_hline()
    # quite unrealistic ones. If one can spend a year, he can buy a few devices...
    print_table_row_ulaes_4c_1d()
    print_table_row_ulaes_4c_4d()
    print_table_row_ulaes_3c_3d()
    print_table_row_ulaes_3c_3d_tear_hw3()
    print_table_row_ulaes_tear_hw3()
    print_table_row_ulaes_tear_hw2()
    print_table_row_ulaes_tear_hw2_heat()
    print_table_row_ulaes_reader()
    print_table_hline()
    print_table_row_ntag224_aes_4c_1d()
    print_table_row_ntag224_aes_4c_4d()
    print_table_row_ntag224_aes_3c_3d()
    print_table_row_ntag224_aes_tear_hw2()
    print_table_row_ntag22x_suncmac()
    print_table_row_ntag22x_suncmac_tear()
    print_table_row_ntag224_reader()
    print_table_footer()


if __name__ == "__main__":
    main()
